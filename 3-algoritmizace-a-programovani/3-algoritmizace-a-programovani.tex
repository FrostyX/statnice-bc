\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}
\usepackage[T1]{fontenc}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{ amssymb }
\usepackage{ mathrsfs }
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amsfonts}
\newtheorem{veta}{Věta}
\newtheorem{definition}{Definice}
\newtheorem{note}{Poznámka}




\begin{document}

\title{Státnicový okruh 3: \\ Algoritmizace a programování}
\maketitle
\newpage
\tableofcontents
\newpage

%-----------------------------------prvni odstavec------------------------------------
\section{}
\paragraph{Lineární datové struktury: seznam, zásobník, fronta. Úloha třídění a rozdělení třídících algoritmů. Metody třídění porovnáváním: insert sort, Select sort, Bubble sort, Quick sort, Merge sort, Heap sort. Další metody třídění: Counting sort, Radix Sort, Bucket sort, vnější třídění. Složitosti třídicích algoritmů. Pořádkové statistiky.}
\newpage

%-----------------------------------druhy odstavec------------------------------------
\section{}
\paragraph{Grafy, stromy, základní pojmy a tvrzení. Vyhledávání a rozdělení vyhledávacích algoritmů. Vyhledávání v lineárních datových strukturách. Binární vyhledávací stromy, průchod a vyhledávání. Red-black stromy, AVL-stromy, B-stromy a jejich struktura, operace vyhledání, vložení a zrušení prvku. Hashování: hashovací funkce, organizace tabulek a způsoby řešení konfliktů.}

\subsection{Grafy}
Grafický způsob vyjádření vztahů mezi nějakými objekty. Objekty jsou v grafu reprezentovány uzly. Vztahy jsou v grafu reprezentovány hranami. Způsob kreslení volíme především tak, aby graf byl přehledný. Hrana vždy začíná a končí v nějakém uzlu. Většinou jsou koncové uzly hrany různé, ale může to být i stejný uzel, pak takové hraně říkáme \textbf{smyčka}. Dva uzly mohou být spojeny více hranami – takovým hranám říkáme \textbf{násobné}. Graf, ve kterém mezi některými uzly je více hran, nazýváme \textbf{multigraf}.
\\ \\
Hrany v grafu mohou být:
\begin{itemize}
	\item \textbf{Neorientované} reprezentují symetrické vztahy mezi uzly. Například v situaci, kdy Petr a Jana jsou bratr a sestra a hrana nám bude v grafu vyjadřovat tento vztah, že jsou sourozenci, tato hrana bude neorientovaná.
	\item \textbf{Orientované} reprezentují jednosměrné, nesymetrické vztahy mezi uzly. Orientace hrany je vyznačena šipkou na jednom jejím konci. Například je-li Eva matkou Petra a Jany a hrany nám budou vyjadřovat vztah, že Eva je jejich rodičem, bude tyto hrany orientované.
\end{itemize}
Podle typu hran dělíme grafy na:
\begin{itemize}
	\item \textbf{Neorientované} – všechny jejich hrany jsou neorientované
	\item \textbf{Orientované} – všechny jejich hrany jsou orientované
	\item \textbf{Smíšené} – obsahují neorientované i orientované hrany
\end{itemize}
\begin{definition}
Graf je dvojice G = (U, H), kde \\
\begin{itemize}
	\item[] U je množina uzlů $U = \{ u_1, u_2, \cdots, u_m \}$\\
	\item[] H je množina hran $H = \{ h_1, h_2, \cdots, h_n \}$
\end{itemize}
\end{definition}
U neorientovaného grafu jsou hrany určeny neuspořádanými dvojicemi svých koncových uzlů $h_i = \{ u_j, u_k\}$, kde $u_j, u_k \in U$ \\
U orientovaného grafu jsou hrany určeny uspořádanými dvojicemi svých koncových uzlů $h_i = \langle u_j, u_k \rangle$, kde $u_j, u_k \in U$ \\
Počet hran se zančí $|H|$. Počet uzlů $|U|$.
\begin{definition}
\textbf{Stupeň uzlu} je počet hran, které jsou s tímto uzel spojeny - mají tento uzel jako koncový. Pro skutečnost, že hrana má daný uzel jako koncový, používáme termín, že hrana s tímto uzlem \textbf{inciduje}.
\end{definition}
U orientovaného grafu navíc rozeznáváme výstupní stupeň uzlu, což je počet hran, které z něho vychází, označujeme ho $d^-(u)$, a vstupní stupeň uzlu, což je počet hran, které do něho vchází, označuje ho $d^+(u)$. Zřejmě pro stupeň uzlu v orientovaném grafu platí $d(u) = d^-(u) + d^+(u) $.
\begin{definition}
V teorii grafů se používají termíny:
\begin{itemize}
	\item Pro uzel, jehož stupeň je nulový, používáme název diskrétní uzel.
	\item Graf, jehož všechny uzly jsou diskrétní, nazveme diskrétní graf.
	\item Dva uzly, jež jsou spojeny hranou, nazveme sousedními uzly.
	\item Pro graf, jehož všechny uzly jsou sousední (má při daném počtu uzlů maximální počet hran), se používá označení úplný graf.
\end{itemize}
\end{definition}
\begin{definition}
Nechť je dán graf $G = (U, H)$. Pak graf $G_1 = (U_1 , H_1 )$ takový, že $U_1 \subset U$ a $H_1 \subset H$, nazveme \textbf{podgrafem grafu G}.
\end{definition}
\subsubsection{Reprezentace grafu v programech}
Graf si můžeme v programu reprezentovat různými způsoby. Můžeme si ho například uložit jako matici sousednosti. Ovšem u rozsáhlejších grafů s větším počtem uzlů je tato matice značně velká a navíc její použití v algoritmech je poměrně neefektivní, neboť v ní musíme pracně hledat.
\subsubsection{Reprezentace pomocí polí}
Struktura grafu je uložena ve dvou polích. První pole má stejný počet prvků, jako je počet uzlů v grafu. Každému uzlu odpovídá jeden prvek pole. V něm je uložena hodnota indexu, od kterého v druhém poli začíná seznam uzlů, jež jsou sousedé tohoto uzlu.
\subsubsection{Reprezentace dynamickou datovou strukturou}
Další možnost je uzel grafu reprezentovat jako strukturovaný datový typ. Každý uzel obsahuje pole (seznam) ukazatelů na sousední uzly.
\subsubsection{Izomorfismus grafů}
\begin{definition}
Neorientované grafy $G_1 = (U_1, H_1)$ a $G_2 = (U_2, H_2)$ jsou izomorfní právě když existuje bijektivní zobrazení $h: U_1 \rightarrow U_2$, pro které platí $\{u, v\} \in H_1$ právě když $\{h(u), h(v)\} \in H_2$.
\end{definition}
\begin{definition}
Orientované grafy $G_1 = (U_1, H_1)$ a $G_2 = (U_2, H_2)$ jsou izomorfní právě když existuje bijektivní zobrazení $h: U_1 \rightarrow U_2$, pro které platí $\langle u, v\rangle \in H_1$ právě když $\langle h(u), h(v)\rangle \in H_2$.
\end{definition}
\url{http://upload.wikimedia.org/wikipedia/commons/9/9a/Graph_isomorphism_a.svg} \\
\url{http://upload.wikimedia.org/wikipedia/commons/8/84/Graph_isomorphism_b.svg} \\
Je zřejmé, že izomorfní grafy musí mít stejný počet uzlů, stejný počet hran, stejný počet uzlů daného stupně atd.
\subsubsection{Souvislost grafu}
\begin{definition}
Nechť je dán graf $G = (U, H)$ a dva jeho uzly u a v. \textbf{Sledem} mezi uzly u a v nazveme posloupnost uzlů a hran $u, h_{i1}, u_{i1}, h_{i2}, u_{i2}, \cdots , u_{ik-1}, h_{ik}, v$ pro kterou platí $h_{ir} = \{u_{ir-1}, u_{ir} \} pro r = 1,\cdots, k $
\end{definition}
Tedy sled je na sebe navazující posloupnost hran, kdy vždy dvě za sebou následující hrany ve sledu mají společný koncový uzel, který je ve sledu uveden mezi nimi. \\
Je-li u=v (počáteční a koncový uzel sledu je stejný), jde o \textbf{uzavřený sled}. \\
\textbf{Tah} mezi uzly u a v je sled mezi těmito dvěma uzly, ve kterém se žádná hrana nevyskytuje vícekrát. \\
\textbf{Cesta} mezi uzly u a v je tah mezi těmito dvěma uzly, ve kterém se žádný jeho vnitřní uzel nevyskytuje vícekrát. \\
Uzavřená cesta (je-li u=v) je označována jako \textbf{kružnice grafu}. \\
\textbf{Orientovaný sled} - všechny jeho hrany mají stejnou orientaci – od počátečního uzlu u ke koncovému uzlu v. \\
Dále jsou to pojmy orientovaný tah, orientovaná cesta a cyklus. Cyklus je označení pro orientovanou kružnici.
\begin{definition}
Graf, mezi jehož každými dvěma uzly existuje cesta, nazveme souvislým grafem.
\end{definition}
\begin{definition}
Komponentou grafu nazveme každý jeho maximální souvislý podgraf. Přitom souvislý podgraf daného grafu považujeme za maximální, jestliže ho už nelze zvětšit přidáním dalších hran, či uzlů daného výchozího grafu tak, aby podgraf byl stále souvislý. Tedy není vlastním podgrafem jiného souvislého podgrafu.
\end{definition}
\begin{veta}
Nechť souvislý graf s m uzly má p komponent. Pak má nejméně m-p hran.
\end{veta}
U orientovaného grafu rozeznáváme dva stupně souvislosti: souvislý a silně souvislý graf.
\begin{definition}
Orientovaný graf je souvislý, jestliže mezi každými jeho dvěma uzly u a v existuje orientovaná cesta buďto z uzlu u do uzlu v nebo z uzlu v do uzlu u.
Orientovaný graf je silně souvislý, jestliže mezi každými jeho dvěma uzly u a v existuje orientovaná cesta z uzlu u do uzlu v a rovněž opačná cesta z uzlu v do uzlu u.
\end{definition}
\subsubsection{Minimální kostry grafu}
Kostra je faktor grafu, který má stejný počet komponent a neobsahuje kružnice.
Připomeňme, že faktor grafu je jeho podgraf, který má stejnou množinu uzlů.
U hranově ohodnocených grafů se v praxi vyskytuje úloha nalezení minimální kostry.
\subsubsection{Vzdálenosti v grafu}
Mějme souvislý graf G = (U, H), jehož hrany jsou ohodnoceny nezápornými reálnými čísly. Čísla, jimiž jsou jednotlivé hrany ohodnoceny, budeme nazývat délkami těchto hran. Délkou cesty budeme nazývat součet délek všech hran obsažených na této cestě.
\begin{definition}
Vzdáleností d(u,v) dvou uzlů u a v souvislém grafu G nazveme délku nejkratší z cest mezi oběma uzly u a v.
\end{definition}
\begin{veta}
Pro libovolné tři uzly u, v a w platí:
\begin{enumerate}
	\item $d(u, v) \geq 0, přičemž d(u, v) = 0 právě když u = v$
	\item $d(u, v) = d(v, u)$
	\item $d(u, v) \leq d(u, w) + d(w, v)$
\end{enumerate}
\end{veta}



\subsection{Stromy}
\begin{definition}
Strom je souvislý graf neobsahující kružnice.
\end{definition}
\begin{veta}
Následující tvrzení pro graf G = (U, H) jsou ekvivalentní:
\begin{enumerate}
	\item Graf G je strom.
	\item Graf G je souvislý a platí $|H| = |U|-1$.
	\item Mezi každými dvěma uzly grafu existuje právě jedna cesta.
	\item Graf G je souvislý a odebráním libovolné hrany se jeho souvislost poruší.
	\item Graf G neobsahuje kružnice a přidáním libovolné hrany vznikne v grafu kružnice
\end{enumerate}
\end{veta}
\begin{definition}
Listy stromu jsou uzly se stupněm 1. Uzly, které mají větší stupeň než je 1, jsou vnitřní uzly stromu.
\end{definition}
\begin{definition}
Kořenový strom je strom, v němž jeden uzel je stanoven jako kořen. Všechny hrany v kořenovém stromu mají přirozenou orientaci – jejich orientace je ve směru od kořene ke vzdálenějším uzlům.
\end{definition}




\subsection{Vyhledávání a rozdělení vyhledávacích algoritmů}
Vyhledávání je další velmi důležitou a často se vyskytující úlohou. Při ní máme zadanou nějakou množinu (multimnožinu) prvků a cílem je nalézt mezi nimi takový prvek, který má danou hodnotu vyhledávacího klíče, anebo případně zjistit, že takový prvek mezi nimi není.




\subsection{Vyhledávání v lineárních datových strukturách}
Mezi nejjednodušší případy vyhledávání patří vyhledávání v lineární datové struktuře, tj. v poli nebo v seznamu. Přepokládáme přitom, že prvky jsou v ní uloženy v libovolném pořadí (nesetříděné). Není zde jiný způsob, než prvky postupně procházet (zpravidla od začátku směrem ke konci) a každý srovnat s hledanou hodnotou. Počet srovnání se přitom pohybuje od 1, jestliže hledaný prvek je hned první, po n, jestliže hledaný prvek je až poslední anebo hledaný prvek mezi prohledávanými prvky není obsažen (nebyl nalezen). Tedy průměrný počet srovnání (je-li prvek nalezen) je $\frac{1+n}{2}$. Maximální počet srovnání je n. \\
Sekvenční vyhledávání v lineární datové struktuře má časovou složitost $\theta (n)$
\subsubsection{Binární vyhledávání v setříděném poli}
V případě pole je pro vyhledávání mnohem příznivější případ, když prvky jsou v něm uspořádány (seřazeny) dle velikosti vyhledávacího klíče.
Zde se dá použít algoritmus binárního vyhledávání, často také nazývaný vyhledávání půlením intervalu. \\ \\
Popis algoritmu \\
Vezmeme prvek, který je v poli uprostřed (je-li počet prvků sudý, jsou uprostřed dva prvky - zde vezmeme jeden z nich, při implementaci metody to zpravidla bývá ten levý), označme jeho index s. \\
Následně provedeme srovnání hledané x hodnoty s hodnotou středního prvku $a_s$ :
\begin{itemize}
	\item Nejprve srovnáme, zda je $x < a_s$ \\
	Pokud ano, pak zřejmě hledaný prvek, pokud v poli vůbec je, musí být v části L, jež je nalevo od středního prvku a s . Je-li část L neprázdná(obsahuje aspoň jeden prvek), rekurzivně na ni provedeme stejný postup. Je-li už prázdná, vyhledávání neúspěšně končí. Hledaný prvek není v poli obsažen.
	\item Pokud neplatí $x < a_s$, uděláme další srovnání. Srovnáme, zda je $x > a_s$ \\
	Pokud ano, musíme v dalším kroku hledání pokračovat v části P, jež je napravo od středního prvku a s . Je-li část P neprázdná (obsahuje aspoň jeden prvek), rekurzivně na ni provedeme stejný postup. Je-li už prázdná, vyhledávání neúspěšně končí.
	\item Pokud není ani $x > a_s$, zbývá už jen možnost, že platí $x = a_s$, čímž vyhledávání končí, neboť prvek $a_s$ je hledaným prvkem.
\end{itemize}
Maximální počet kroků logaritmicky závisí na počtu prvků v prohledávané posloupnosti. V každém kroku provádíme nejvýše dvě operace srovnání. První operací zjistíme, zda hledaný prvek je menší než střední prvek. Pokud ano, pokračujeme v hledání v části nalevo. Pokud ne, druhou operací srovnání zjistíme, zda hledaný je větší než střední prvek, čímž rozhodneme, zda pokračovat v hledání v části napravo anebo už jsme hledaný prvek našli. \\
Složitost binárního vyhledávání je $\theta(ln(n))$




\subsection{Binární vyhledávací stromy}
Binární vyhledávání má velmi příznivou časovou složitost. Problém ovšem nastane, když se tato množina v průběhu času mění, tj. jsou k ní přidávány nové prvky nebo z ní jsou naopak některé prvky odebírány.
Vkládání prvků doprostřed pole nebo jejich odebírání zprostředka pole je poměrně neefektivní operace, neboť je spojena s přesuny poměrné značné části prvků v poli. Pro takovéto případy je výhodnější použít vyhledávací stromy.
\paragraph{Binární vyhledávací stromy}
jsou binární stromy s vlastnostmi:
\begin{itemize}
	\item V každém uzlu stromu je uložen jeden datový prvek.
	\item Každý uzel má nanejvýš dva potomky - levého a pravého.
	\item Pro každý uzel u a prvek v něm uložený c platí, že prvky uložené v levém podstromu uzlu u (má-li uzel u levý podstrom) jsou menší než prvek c a prvky uložené v pravém podstromu uzlu u (má-li uzel u pravý podstrom) jsou větší než prvek c.
\end{itemize}
\subsubsection{Vyhledání prvku}
\begin{enumerate}
	\item Počáteční krok \\
	Uzel, který je v daném okamžiku vyhledávání aktuální, budeme označovat u. Na začátku jím bude kořen stromu. Hledaná hodnota nechť je x.
	\item Průběžný krok \\
	Vezmeme prvek obsažený v aktuálním uzlu u, označme ho c, a provedeme jeho srovnání s hledanou hodnotou x:
	\begin{itemize}
		\item Nejprve srovnáme, zda je x < c: \\
		Pokud ano, pak je nutné v hledání pokračovat v levém podstromu. Jako nový aktuální uzel u položíme levého následníka současného aktuálního uzlu a znovu provedeme krok 2. \\
		Pokud současný aktuální uzel levého následníka nemá, vyhledávání končí - hledaný prvek není ve stromu obsažen.
		\item Pokud není x < c, srovnáme, zda je x > c: \\
		Pokud ano, je nutné v hledání pokračovat v pravém podstromu. Jako nový aktuální uzel u položíme pravého následníka současného aktuálního uzlu a opět provedeme krok 2. \\
		Pokud uzel pravého následníka nemá, vyhledávání končí, hledaný prvek není ve stromu obsažen.
		\item Pokud není x > c, zbývá už jen případ, že platí x = c, čímž jsme u konce hledání, neboť prvek c obsažený v současném aktuálním uzlu u je tím hledaným prvkem.
	\end{itemize}
\end{enumerate}
Časová složitost $\theta(h)$, kde h je výška vyhledávacího stromu.
\subsubsection{Přidání prvku}
Operace přidání prvku do binárního vyhledávacího stromu znamená na příslušném místě přidat do stromu uzel, do kterého nový prvek vložíme. Označme přidávaný prvek x. Provedeme jeho vyhledání ve stromu. Použijeme k tomu již popsaný algoritmus vyhledávání. Ten může skončit třemi způsoby:
\begin{itemize}
	\item Prvek x byl ve stromu nalezen. Tím přidávání končí, neboť prvek x už je ve stromu obsažen a u vyhledávacích stromů se nepředpokládá vícenásobný výskyt stejného prvku.
 	\item Vyhledávání skončilo v uzlu u s prvkem c, přičemž x < c a přitom uzel u už nemá levého následníka. V tom případě přidáme ke stromu nový uzel jako levého následníka uzlu u a do něho nový prvek x vložíme.
	\item Vyhledávání skončilo v uzlu u s prvkem c, přičemž x > c a přitom uzel u už nemá pravého následníka. V tom případě přidáme ke stromu pravého následníka uzlu u, do kterého nový prvek x vložíme.
\end{itemize}
Časová složitost $\theta(h)$, kde h je výška vyhledávacího stromu.
\subsubsection{Odebrání prvku}
Operace odebrání prvku z binárního stromu znamená na příslušném místě zrušení uzlu ve stromu. Označme odebíraný prvek x. Vyhledáme prvek x ve stromu. Vyhledání může skončit třemi způsoby:
\begin{itemize}
	\item Prvek x nebyl ve stromu nalezen – není co odebrat.
	\item Prvek byl nalezen v uzlu v, který má nejvýše jednoho následníka.Tento uzel zrušíme.
	\item Prvek byl nalezen v uzlu v, který má dva následníky. V tomto případě do uzlu v přesuneme buďto nejpravější (největší) prvek z jeho levého podstromu anebo nejlevější (nejmenší) prvek z jeho pravého podstromu a uzel, z kterého byl prvek přesunut, zrušíme.
\end{itemize}
Časová složitost $\theta(h)$, kde h je výška vyhledávacího stromu.




\subsection{Red-black stromy}
Červeno-černé stromy jsou vyvážené binární vyhledávací stromy. Mají obdobnou strukturu jako B-stromy řádu 4.
\paragraph{B-stromy řádu 4}
jsou vyvážené vyhledávací stromy s vlastnostmi:
\begin{itemize}
	\item V každém uzlu mohou být uloženy 1-3 datové prvky.
	\item Každý uzel je list nebo má o 1 následníka více, než je počet prvků uložených v uzlu.
	\item Pro každý prvek uložený ve stromu platí pravidlo, že prvky uložené ve stejném uzlu vlevo od něho jsou menší a prvky uložené vpravo od něho jsou větší. Totéž platí pro podstromy – prvky v podstromu, který je vlevo, jsou menší a prvky v podstromu vpravo jsou větší.
	\item Všechny listy mají stejnou vzdálenost od kořene (strom je vyvážený).
\end{itemize}
\subsubsection{Vytvoření RB stromu z B-stromu}
Jednotlivé uzly B-stromu nahradíme 1-3 binárními uzly. Horní nahrazující uzel bude černý, uzly pod ním budou červené uzly. Horní uzel bude s uzly pod ním spojen červenými hranami (viz obrázek RBstrom.jpg).
\subsubsection{Vlastnosti RB stromu}
\begin{itemize}
	\item Kořenový uzel je vždy černý. Barva ostatních uzlů je dána barvou hrany, kterou je uzel spojen s předchůdcem.
	\item Mezi kořenem a libovolným listovým uzlem je stejný počet černých hran (a tím i černých uzlů).
	\item Ve stromu nikdy nenásledují dvě červené hrany po sobě (a tím i nikdy nenásledují dva červené uzly po sobě).
	\item Nechť mezi kořenem a listem je m černých hran. Pak mezi kořenem a libovolným listem je nejvýše m+1 červených hran.
\end{itemize}
\subsubsection{Přidání prvku}
Přidání probíhá standardním způsobem jako v běžném binárním vyhledávacím stromu. \\
Označení: x - přidávaný prvek \\
Vyhledáme prvek x ve stromu. Vyhledání může skončit třemi způsoby:
\begin{itemize}
	\item Prvek x byl ve stromu nalezen – nelze ho znovu přidat a přidávání tím končí.
	\item Vyhledávání skončilo v uzlu u, ve kterém je uložen prvek c, přičemž x < c a uzel u nemá levého následovníka. Vytvoříme nový uzel jako levého následovníka uzlu u a do něho dáme přidávaný prvek x.
	\item Vyhledávání skončilo v uzlu u s prvkem c, přičemž x > c a uzel u nemá pravého následovníka. Vytvoříme pravého následovníka uzlu u a do něho dáme přidávaný prvek x.
\end{itemize}
Přidávání je tedy realizováno vytvořením nového uzlu a jeho spojením hranou s uzlem u, ve kterém skončilo vyhledávání. Vytvořený uzel bude novým listem stromu. Aby zůstala zachována podmínka, že mezi kořenem a libovolným listem byl stejný počet černých hran, musíme nový uzel spojit s uzlem u červenou hranou a nový uzel bude červený uzel. Pokud uzel u je černý uzel, operace přidání je ukončena. Jestliže ale uzel u je červený uzel, jsou nyní ve stromu dvě červené hrany (dva červené uzly) po sobě.
\paragraph{Odstranění dvou červených uzlů po sobě}
rotace x výměna barev. \\
\begin{itemize}
	\item Horní z dvojice po sobě následujících červených uzlů nemá červeného sourozence – jednoduchá nebo dvojitá rotace.
	\item Horní z dvojice červených uzlů má červeného sourozence. Změníme jejich obarvení na černou barvu a barvu jejich předchůdce, pokud to není kořen, změníme na červenou barvu.
\end{itemize}
\subsubsection{Odebrání prvku}
Označení: x - odebíraný prvek
\begin{enumerate}
	\item Vyhledáme prvek x ve stromu. Vyhledání může skončit třemi způsoby:
	\begin{itemize}
		\item Prvek x nebyl ve stromu nalezen – není co odebrat.
		\item Prvek byl nalezen v uzlu v, který má nejvýše jednoho následníka. Tento uzel zrušíme.
		\item Prvek byl nalezen v uzlu v, který má dva následníky. V tomto případě do uzlu v přesuneme buďto nejpravější (největší) prvek z jeho levého podstromu anebo nejlevější (nejmenší) prvek z jeho pravého podstromu a uzel, z kterého byl prvek přesunut, zrušíme.
	\end{itemize}
	\item Další postup závisí na tom, jakou barvu má rušený uzel.
	\begin{itemize}
		\item Rušený uzel má červenou barvu. V tomto případě zrušení uzlu neovlivní počet černých uzlů (a černých hran) a odebrání je ukončeno.
		\item Rušený uzel má černou barvu a má červeného následníka. Následníka přebarvíme na černou barvu. Tím počet černých uzlů (a černých hran) zůstane zachován a odebrání je ukončeno.
		\item Rušený uzel v má černou barvu a nemá červeného následníka. Uzel v obarvíme jako dvojitý černý. Toto obarvení vyjadřuje, že zrušením uzlu by nastal deficit černé barvy na cestách od kořenu k listům, na kterých tento uzel leží. \\
		Další postup je transformacemi dosáhnout, aby ve stromu nebyl žádný uzel s dvojitým černým obarvením. Přitom u uzlu, který chceme zrušit, lze při odstranění jeho dvojitého černého obarvení ho ze stromu odstranit.
	\end{itemize}
\end{enumerate}
\paragraph{Odstranění dvojitého černého obarvení uzlu}
rotace x výměna barev.
\begin{itemize}
	\item Sourozenec uzlu s dvojitým černým obarvením je černý uzel a tento má přitom aspoň jednoho červeného následníka – jednoduchá nebo dvojitá rotace (spojená s určitým přebarvením uzlů).
	\item Sourozenec uzlu v s dvojitým černým obarvením je černý uzel a tento přitom nemá žádného červeného následníka. Jedno černé obarvení od obou uzlů (uzlu v a jeho sourozence) odebereme a k předchůdci těchto uzlů naopak jedno černé obarvení přidáme. Uzel v bude tímto mít jedno černé obarvení a jeho sourozenec bude červeně obarven.
	\begin{itemize}
		\item Předchůdce uzlu v je červený uzel – nyní bude černý uzel.
		\item Předchůdce uzlu v je černý uzel. Pokud to není kořen, bude mít nyní dvojité černé obarvení.
	\end{itemize}
	\item Sourozenec uzlu v s dvojitým černým obarvením je červený uzel – jednoduchá rotace.
\end{itemize}
\paragraph{Časová složitost operací} je závislá na výšce červeno-černého stromu. Odtud $\theta(ln(n))$.




\subsection{AVL stromy}
Jsou určitým způsobem vyvážené binární vyhledávací stromy.
Vyváženost v AVL stromu je zajištěna podmínkou, že pro každý uzel u stromu musí platit, že rozdíl mezi výškou jeho levého podstromu a výškou jeho pravého podstromu je nejvýše 1. Přitom výškou podstromu zde rozumíme maximum ze vzdáleností od uzlu u k uzlům daného podstromu, tedy vzdálenost mezi uzlem u a uzly, které jsou úplně naspodu podstromu. Pokud uzel nemá daného následníka (levého, pravého), je výška tohoto podstromu 0.
Při operaci přidání prvku do stromu je přidán nový uzel, při operaci odebrání prvku ze stromu je naopak uzel zrušen. Tyto operaci v příslušném místě, kde byl přidán nebo zrušen uzel, mění tvar stromu a mohou vést k porušení uvedené podmínky vyvážení u některého uzlu stromu. Proto je po operaci přidání nebo odebrání nutné ověřit, zda k této situaci nedošlo. Aby toto ověřování proběhlo efektivně, je v každém uzlu proměnná b (b=balance), která je označovaná jako faktor vyvážení uzlu a která obsahuje informaci o jeho stávajícím vyvážení.
Uzel je vyvážený, jestliže jeho faktor vyvážení je 1, 0 nebo -1. Při přidání prvku do stromu nebo odebrání prvku ze stromu se v důsledku změny tvaru stromu může v některém uzlu jeho faktor vyvážení změnit na 2 nebo -2. V tom případě je zapotřebí udělat transformaci, která obnoví vyvážení daného uzlu.
\subsubsection{Přidání prvku}
Operace přidání prvku do AVL stromu znamená na příslušném místě přidání uzlu do stromu, do kterého nový prvek vložíme, a následně aktualizujeme v příslušných částích stromu údaje o vyvážení v uzlech a ověřujeme, zda v některém uzlu nedošlo k narušení vyvážení stromu, a pokud ano, uzel vhodnou transformací vyvážíme. \\
Označení: x - přidávaný prvek
\begin{enumerate}
	\item Vyhledáme prvek x ve stromu. Vyhledání může skončit třemi způsoby:
	\begin{itemize}
		\item Prvek x byl ve stromu nalezen. Tím přidávání končí, neboť prvek x už je ve stromu obsažen a nelze ho přidat.
		\item Vyhledání skončilo v uzlu u, ve kterém je uložen prvek c, přičemž x < c a přitom uzel u už nemá levého následníka. V tom případě přidáme ke stromu nový uzel v jako levého následníka uzlu u a do něho nový prvek x vložíme.
		\item Vyhledání skončilo v uzlu u s prvkem c, přičemž x > c a přitom uzel u už nemá pravého následníka. V tom případě přidáme ke stromu nový uzel v jako pravého následníka uzlu u a do něho nový prvek x vložíme.
	\end{itemize}
	\item Po přidání uzlu procházíme uzly stromu na cestě od přidaného uzlu v směrem ke kořenu. Pro každý procházený uzel u na cestě aktualizujeme jeho faktor vyvážení.
	\begin{itemize}
		\item Pokud přidaný prvek je v levém podstromu aktuálního uzlu u, jeho faktor vyvážení zvýšíme o 1. \\
		Po aktualizaci faktoru vyvážení mohou nastat případy:
		\begin{itemize}
			\item Faktor vyvážení uzlu u je nyní 0. V tomto případě přidání prvku x nemá vliv na faktory vyvážení dalších uzlů na cestě ke kořenu a operace přidání tím skončila.
			\item Faktor vyvážení uzlu u je nyní 1. Je-li uzel u již kořen, operace přidání skončila. Jinak aktuální uzlem u učiníme předchůdce současného uzlu u a opět krok 2.
			\item Faktor vyvážení uzlu u je nyní 2. Uzel u je nevyvážený - vyvážíme ho vhodnou transformací (RR, RL). Po vyvážení:
			\begin{itemize}
				\item Je-li uzel u již kořen, operace přidání skončila.
				\item Je-li po vyvážení hodnota faktoru vyvážení uzlu u rovna 0, operace přidání je ukončena (maximum z výšek podstromů uzlu u se transformací snížilo o 1, tudíž už to nemá vliv na faktor vyvážení předchůdce uzlu u). Jinak přejdeme k předchůdci uzlu u a opět krok 2.
			\end{itemize}
		\end{itemize}
		\item Pokud přidaný prvek je v pravém podstromu aktuálního uzlu u, jeho faktor vyvážení snížíme o 1. \\
		Po aktualizaci faktoru vyvážení mohou nastat případy:
		\begin{itemize}
			\item Faktor vyvážení uzlu u je nyní 0. V tomto případě přidání prvku x nemá vliv na faktory vyvážení dalších uzlů na cestě ke kořenu a operace přidání tím skončila.
			\item Faktor vyvážení uzlu u je nyní -1. Je-li uzel u již kořen, operace přidání skončila. Jinak aktuální uzlem u učiníme předchůdce současného uzlu u a opět krok 2.
			\item Faktor vyvážení uzlu u je nyní -2. Uzel u je nevyvážený - vyvážíme ho vhodnou transformací (LL, LR). Po vyvážení:
			\begin{itemize}
				\item Je-li uzel u již kořen, operace přidání skončila.
				\item Je-li po vyvážení hodnota faktoru vyvážení uzlu u rovna 0, operace přidání je ukončena (maximum z výšek podstromů uzlu u se transformací snížilo o 1, tudíž už to nemá vliv na faktor vyvážení předchůdce uzlu u). Jinak přejdeme k předchůdci uzlu u a opět krok 2.
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{enumerate}
\subsubsection{Odebrání prvku}
Operace odebrání prvku z AVL stromu znamená na příslušném místě zrušení uzlu ve stromu. Následně aktualizujeme v příslušných částích stromu údaje o vyvážení v uzlech a ověřujeme, zda v některém uzlu nedošlo k narušení vyvážení stromu, a pokud ano, uzel vhodnou transformací vyvážíme. \\
Označení: x - odebíraný prvek
\begin{enumerate}
	\item Vyhledáme prvek x ve stromu. Vyhledání může skončit třemi způsoby:
	\begin{itemize}
		\item Prvek x nebyl ve stromu nalezen – není co odebrat.
		\item Prvek byl nalezen v uzlu v, který má nejvýše jednoho následníka.Tento uzel zrušíme.
		\item Prvek byl nalezen v uzlu v, který má dva následníky. V tomto případě do uzlu v přesuneme buďto nejpravější (největší) prvek z jeho levého podstromu anebo nejlevější (nejmenší) prvek z jeho pravého podstromu a uzel, z kterého byl prvek přesunut, zrušíme.
	\end{itemize}
	\item Po zrušení uzlu procházíme uzly stromu na cestě od zrušeného uzlu směrem ke kořenu. Pro každý procházený uzel u na cestě aktualizujeme jeho hodnotu vyvážení b.
	\begin{itemize}
		\item Pokud zrušený uzel byl v levém podstromu aktuálního uzlu u, jeho faktor vyvážení snížíme o 1. \\
		Po aktualizaci faktoru vyvážení mohou nastat případy:
		\begin{itemize}
			\item Faktor vyvážení uzlu u je nyní -1. V tomto případě zrušení uzlu nemá vliv na faktory vyvážení dalších uzlů na cestě ke kořenu a operace odebrání tím skončila.
			\item Faktor vyvážení uzlu u je nyní 0. Je-li uzel u již kořen, operace odebrání skončila. Jinak aktuální uzlem u učiníme předchůdce současného uzlu u a opět krok 2.
			\item Faktor vyvážení uzlu u je nyní -2. Uzel u je nevyvážený - vyvážíme ho vhodnou transformací (LL, LR). Po vyvážení:
			\begin{itemize}
				\item Je-li uzel u již kořen, operace odebrání skončila.
				\item Je-li po vyvážení faktor vyvážení uzlu u roven -1, operace přidání je ukončena (maximum z výšek podstromů uzlu u se transformací zvýšilo o 1, tudíž už to nemá vliv na faktor vyvážení předchůdce uzlu u). Jinak přejdeme k předchůdci uzlu u a opět krok 2.
			\end{itemize}
		\end{itemize}
		\item Pokud zrušený uzel je v pravém podstromu aktuálního uzlu u, jeho faktor vyvážení zvýšíme o 1. \\
		Po aktualizaci faktoru vyvážení mohou nastat případy:
		\begin{itemize}
			\item Faktor vyvážení uzlu u je nyní 1. V tomto případě zrušení uzlu nemá vliv na faktory vyvážení dalších uzlů na cestě ke kořenu a operace přidání tím skončila.
			\item Faktor vyvážení uzlu u je nyní 0. Je-li uzel u již kořen, operace odebrání skončila. Jinak aktuální uzlem u učiníme předchůdce současného uzlu u a opět krok 2.
			\item Faktor vyvážení uzlu u je nyní 2. Uzel u je nevyvážený - vyvážíme ho vhodnou transformací (RR, RL). Po vyvážení:
			\begin{itemize}
				\item Je-li uzel u již kořen, operace přidání skončila.
				\item Je-li po vyvážení faktor vyvážení uzlu u roven 1, operace přidání je ukončena (maximum z výšek podstromů uzlu u setransformací zvýšilo o 1, tudíž už to nemá vliv na faktor vyvážení předchůdce uzlu u). Jinak přejdeme k předchůdci uzlu u a opět krok 2.
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{enumerate}
\paragraph{Časová složitost operací} $\theta(log(n))$.




\subsection{B-stromy}
B-stromy jsou velmi významným typem vyhledávacích stromů. Mají v uzlech uloženo více prvků. Struktura B-stromů je definována následujícími vlastnostmi:
\begin{itemize}
	\item Kapacita uzlu (počet prvků, který lze do uzlu uložit) je u všech uzlů stromu stejná a volíme ji před začátkem vytváření stromu, kapacitu označme r $(r \geq 2)$ Protože v B-stromech má významnou úlohu polovina z tohoto počtu, zaveďme si pro ni samostatné označení $p = \frac{r}{2}$ pro r sudé a $p = \frac{r-1}{2}$ pro r liché.
	\item Důležité pro efektivní využití uzlů je jejich zaplnění. Všechny uzly vyjma kořene musí být aspoň z poloviny zaplněny prvky pro r sudé nebo p prvky pro r liché, tedy počet prvků v uzlech uložených musí být v rozmezí p až r prvků. Jedině u kořene stačí, aby obsahoval aspoň jeden prvek, tedy jeho zaplnění je v rozmezí 1 až r prvků.
	\item Prvky uložené v uzlu jsou v něm seřazeny vzestupně dle velikosti.
	\item Uzel je buďto list anebo má o jednoho následníka více, než je počet prvků v něm uložený. \\
	Přitom pro prvky v jednotlivých podstromech, které těmito následníky začínají, platí:
	\begin{itemize}
		\item Pro každý prvek d v podstromu začínajícího uzlem $násl_0$ platí $d < c_1$.
		\item Pro každý prvek d v podstromu začínajícího uzlem $násl_1$ platí $c_1 < d < c_2$.
		\item ............
		\item Pro každý prvek d v podstromu začínajícího uzlem $násl_{k-1}$ platí $c_{k-1} < d <c_k$.
		\item Pro každý prvek d v podstromu začínajícího uzlem $násl_k$ platí $d > c_k$.
	\end{itemize}
	\item Listy jsou v B-stromu jen v jeho poslední (nejspodnější) úrovni.
\end{itemize}
Podle maximálního počtu následníků označujeme i řád B-stromu. B-strom s kapacitou uzlu r má řád r + 1, neboť nelistový uzel může mít až r + 1 následníků.
\subsubsection{Vyhledání prvku}
\begin{enumerate}
	\item Počáteční krok \\
	Uzel, který je v daném okamžiku vyhledávání aktuální, budeme označovat u. Na začátku jím bude kořen stromu. \\
	Hledaná hodnota nechť je x.
	\item Průběžný krok \\
	Provedeme vyhledání hodnoty mezi prvky uloženými v aktuálním uzlu u. Protože prvky jsou v uzlu setříděné, lze k tomu použít binární vyhledávání. To použijeme v případě, kdy kapacita uzlů je zvolena dostatečně velká, aby se to vyplatilo. Vyhledání může skončit třemi způsoby:
	\begin{itemize}
		\item Prvek byl v aktuálním uzlu u nalezen, čímž vyhledávání úspěšně končí.
		\item Prvek nebyl v aktuálním uzlu u nalezen a tento uzel je list. Tím vyhledávání končí - hledaný prvek není ve stromu obsažen.
		\item Prvek nebyl v aktuálním uzlu u nalezen a tento uzel je nelistový. V tom případě vyhledávání skončilo v místě, kde je odkaz na následníka, ve kterém vyhledávání má pokračovat (tj. na následníka, kterým začíná podstrom, jež by hledaný prvek měl obsahovat). Tohoto následníka učiníme novým aktuální uzlem a opět se provede krok 2.
	\end{itemize}
\end{enumerate}
\subsubsection{Přidání prvku}
Chceme-li do B-stromu přidat prvek, znamená to najít příslušný uzel, do kterého nový prvek patří, a následně ověřit, zda přitom nedošlo k přeplnění, a pokud ano, provést rozdělení uzlu.
\begin{enumerate}
	\item Přidání prvku \\
	Označme přidávaný prvek x. Provedeme je vyhledání ve stromu. Použijeme k tomu běžný algoritmus pro vyhledání. Ten může skončit dvěma způsoby:
	\begin{itemize}
		\item Prvek x byl ve stromu nalezen. Tím přidávání končí, neboť prvek x už je ve stromu obsažen (u vyhledávacích stromů se nepředpokládá vícenásobný výskyt stejného prvku).
		\item Vyhledávání skončilo v listovém uzlu u v místě, kam nový prvek podle velikosti vzhledem k ostatním prvků patří. Prvek na toto místo vložíme. Pokud uzel u předtím nebyl zcela zaplněn, operace přidání tím končí. Jinak provedeme rozdělení uzlu.
	\end{itemize}
	\item Rozdělení uzlu \\
	Jestliže uzel u má po přidání r+1 prvků, tedy došlo k jeho přeplnění uzlu, rozdělíme ho na tři části: \\
	p prvků na začátku uzlu + prvek uprostřed uzlu + p prvků na konci uzlu. \\
	Části s p prvky budou tvořit nové listy. Prvek, jež je v uzlu u uprostřed, se přesune do předchůdce na místo, kde byl původní odkaz na list. Po přesunu nalevo a napravo od něho vytvoříme nové odkazy na nově vzniklé listy.
\end{enumerate}
Zřejmě po přidání uzlu do předchůdce v něm může dojít rovněž k jeho přeplnění, pokud předtím byl zcela zaplněn. To se řeší stejným způsobem - rozdělením tohoto uzlu na tři části s počtem prvků p+1+p. Dvě jeho části s p prvky budou tvořit nové uzly a zbývající prostřední prvek vložíme do jeho předchůdce. Takto postupujeme směrem nahoru, až buďto narazíme na uzel, u kterého po vložení dalšího prvku nedojde k přeplnění, anebo se nakonec dostaneme až ke kořenu. Pokud i u něho dojde k přeplnění, rozdělí se a střední prvek v tomto rozdělení bude nyní nový kořen. V této situaci dojde ke zvětšení výšky stromu.
\subsubsection{Odebrání prvku}
Chceme-li z B-stromu odebrat prvek, znamená to vyhledat uzel, ve kterém se prvek nachází, prvek z něho odstranit a následně ověřit, zda odebráním prvku nepoklesl počet prvků v daném uzlu pod přípustnou mez, a pokud ano, je nutné to vyřešit.
\begin{enumerate}
	\item Odebrání prvku: \\
	Označme odstraňovaný prvek x. Provedeme jeho vyhledání ve stromu. Použijeme k tomu běžný algoritmus pro vyhledání. Ten může skončit třemi způsoby:
	\begin{itemize}
		\item Prvek x nebyl ve stromu nalezen - není co odebrat.
		\item Prvek x byl nalezen v listovém uzlu. Prvek z uzlu odstraníme. Pokud list je po zrušení prvku aspoň z poloviny zaplněn, operace odebrání končí. Jinak přejdeme ke kroku 2.
		\item Prvek x byl nalezen v uzlu u, který není listem. Prvek x z uzlu odstraníme a na volné místo v uzlu u přesuneme buďto největší prvek z jeho levého podstromu, což je poslední prvek v nejpravějším listu podstromu, anebo nejmenší prvek z jeho pravého podstromu, což je první prvek v nejlevějším listu podstromu. Pokud list, odkud jsme prvek přesunuli, je stále aspoň z poloviny zaplněn, operace odebrání prvku končí. Jinak přejdeme ke kroku 2.
	\end{itemize}
	\item Zmenšení počtu prvků v uzlu \\
	Sem se dostáváme v situaci, kdy po odstranění prvku ze stromu je nyní ve stromu list v, který má jen p-1 prvků. Jak se tento stav řeší, závisí na zaplnění přímých sousedů listu. Jsou dvě možnosti:
	\begin{itemize}
		\item List v má aspoň jednoho přímého souseda, který má více než p prvků. Přímým sousedem zde máme na mysli uzel, který je nejen vedle uzlu v, ale má i stejného předchůdce. Pak do listu v přesuneme prvek z předchůdce a na prázdné místo v předchůdci přesuneme příslušný prvek ze souseda. Následující obrázek ukazuje tento přesun pro oba možné přímé sousedy, nejdříve pro levého souseda, pak pro pravého souseda.
		\item List v má jen přímé sousedy, které mají právě p prvků. Pak vytvoříme nový list s r prvky tak, že sloučíme prvky z listu v + prvek z předchůdce + prvky ze souseda. \\
		Je zřejmé, že tímto ubyl jeden prvek v předchůdci. Pokud tento má nyní jen p-1 prvků, řeší se to analogicky v závislosti na tom, kolik prvků mají jeho přímí sousedé. Takto se můžeme případně dostat až k uzlu, který je následníkemkořene. Pokud je vytvořen nový uzel sloučením s jeho přímým sousedem a pokud kořen v této chvíli má jen jeden prvek, dojde přitom k vytvoření nového kořene a zároveň ke snížení výšky stromu. Na následujícím obrázku je tato situace pro případ, kdy je pro sloučení vzat levý přímý soused.
	\end{itemize}
\end{enumerate}
\paragraph{Časová složitost operací} $\theta(log(n))$.




\subsection{Hašování}
Datová struktura použitá v hašování pro uložení prvků je tabulka. Tabulka se skládá z řádků. U hašování pro řádky tabulky používáme označení přihrádky. V každé přihrádce je místo pro uložení jednoho datového prvku. Počet přihrádek v tabulce, tedy kapacitu tabulky označme m. Na jednotlivé přihrádky v tabulce se odkazujeme (adresujeme je) čísly 0 až m-1. Při implementaci hašování se tabulka snadno realizuje pomocí pole. Datový typ prvků pole se zvolí takový, aby se do něho daly uložit údaje, které ukládáme do přihrádek tabulky. Tím každý prvek pole reprezentuje jednu přihrádku tabulky a indexování prvků pole odpovídá adresování jednotlivých přihrádek v tabulce. \\
Základem hašování je hašovací funkce. Je to zobrazení, které hodnotě prvku (nebo vyhledávacímu klíči prvku, pokud prvek je strukturovaný typ) přiřadí číslo některé z přihrádek v tabulce, tedy číslo v rozmezí 0 až m-1. Hašovací funkce se typicky sestaví ze dvou funkcí. Ta první hodnotu prvku zobrazí na celé (nezáporné) číslo. Druhá celé číslo zobrazí na číslo přihrádky v tabulce, tedy na celé číslo z intervalu <0,m-1>. \\
Cílem hašovací funkce je rovnoměrné rozmístění prvků v tabulce. Z toho plyne, že první funkce, která převádí hodnotu prvku na celé číslo, by měla mít vlastnosti:
\begin{itemize}
	\item Zobrazovat hodnoty prvků na co největší počet různých celých čísel.
	\item Zobrazení na celá čísla by mělo být rovnoměrné (na jednotlivá čísla by se měl zobrazovat přibližně stejný počet prvků, které chceme do hašovací tabulky uložit).
\end{itemize}
Dalším přirozeným požadavkem na hašovací funkci je, aby její výpočet nebyl příliš časově náročný.
\subsubsection{Hašovací funkce pro řetězce}
Řetězec si označme $z_1 z_2 \cdots z_k$, kde $z_i$ je znak z řetězce a k je délka řetězce.
\paragraph{První část hašovací funkce}
Jedna z jednodušších funkcí zobrazující řetězec na celé číslo je $c_1 ( z_1 z_2 \cdots z_k ) = p \ast asc ( z_1 ) + q \ast asc ( z_2 ) + asc ( z_k ) + k$, kde p a q jsou zvolené konstanty, nejlépe prvočísla (např. p=127, q=31), protože ty mají nejlepší předpoklady pro rovnoměrné zobrazení do množiny celých čísel. Funkce asc převádí znak na jeho ASCII hodnotu (nebo Unicode hodnotu). \\
Dokonalejší, ale na druhé straně náročnější na výpočet, je funkce $c_2 ( z_1 z_2 \cdots z_k ) = p^{k-1} \ast asc ( z_1 ) + p^{k-2} \ast asc ( z_2 ) + \cdots + p \ast asc ( z_{k-1} ) + asc ( z_k )$, kde p je konstanta, opět nejlépe prvočíslo (např. p=31).
\paragraph{Drugá část hashovací funkce}
která převádí celé číslo na číslo přihrádky v hašovací tabulce, je velmi jednoduchá. Používá se pro ni operace modulo. Obecný zápis hašovací funkce je $h ( x ) = c ( x ) mod m$, kde c(x) je první část hašovací funkce a m je rozsah (počet přihrádek) hašovací tabulky. Opět je nejlepší zvolit m prvočíslo, protože to nemá žádného netriviálního vlastního dělitele, čímž poskytuje nejlepší předpoklady pro rovnoměrné rozmístění prvků v tabulce. \\ \\
Vedle prvočíselného počtu přihrádek v tabulce se v praxi používá i počet přihrádek, který je mocninou čísla 2. Tento počet nemá tak dobré předpoklady pro rovnoměrné rozmístění prvků v tabulce, ale výpočet hašovací funkce je snadnější, protože místo operace modulo lze použít jednodušší operaci bitového součinu.
\subsubsection{Metoda otevřeného adresování}
V případě, kdy pozice v tabulce vypočítaná hašovací funkcí je obsazena, počítá další pozice tak dlouho, dokud se nenajde volná pozice anebo se nezjistí, že tabulka už je zaplněna.
\paragraph{Lineární hledání}
nové pozice počítáme funkcí $H(x, i) = (h(x) + i)\:mod\:m$, kde h(x) je výchozí hašovací funkce, i je celočíselný parametr a m je rozsah tabulky. \\
Lineární umísťování za sebou vede k vytváření nežádoucích shluků. \textbf{Shlukem} nazýváme větší počty za sebou následujících obsazených přihrádek tabulky. Pokud je vypočítaná primární pozice obsazená a je přitom uvnitř takového shluku, znamená to při lineárním hledání, že musíme projít všechny přihrádky v tomto shluku za primární pozicí, než se dostaneme k nějaké volné sekundární pozici, abychom prvek do ní mohli uložit. Přitom shluky prodlužují nejen operaci přidání prvku do tabulky, ale také vyhledávání prvku v tabulce. Při vyhledávání začínáme na primární pozici a pokud na ní prvek není a tato pozice je přitom obsazena (je na ní jiný prvek), procházíme sekundární pozice tak dlouho, dokud prvek nenajdeme nebo se nedostaneme k volné pozici, což je příznakem toho, že hledaný prvek v tabulce není.
\paragraph{Kvadratické hledání}
Proto místo lineárního hledání se často používá kvadratické hledání. U něho sice také vznikají shluky, ale už v menší míře. Hašovací funkce používaná pro kvadratické hledání má většinou jednoduchý tvar $H(x, i) = (h(x) + i^2 )\:mod\:m$. U ní je už určitý problém, že během hledání se můžeme touto funkcí dostat znovu na stejnou pozici, kterou jsme již prošli, aniž jsme přitom vyčerpali celou tabulku.
\paragraph{Dvojí hašování}
je propracovanější metoda. Hašovací funkce má tvar $H(x, i) = (h(x) + i \ast h_2(x))\:mod\:m$, kde $h_2$ je sekundární hašovací funkce v rozmezí hodnot 1 až m-1. V praxi nejčastějí vychází z primární funkce. Máme funkci $c(x)$, primírní hašovací funkci $h(x) = c(x)\:mod\:m$. Sekundární hašovací funkce vznikne jako $h_2(x) = 1 + (c(x)\:mod\:(m -1))$. Pozici nyní můžeme počítat rekurzivně \\
$H(x,0) = h(x)$ \\ $H(x, i) = (H(x, i-1) + h_2(x))\:mod\:m\;$	pro i = 1,2,3,...
\paragraph{Vyhledávání v tabulce}
Při vyhledávání v hašovací tabulce nejprve vypočítáme hodnotu hašovací funkce pro hledaný prvek x. Podíváme se do tabulky na přihrádku, na kterou ukazuje hodnota hašovací funkce. Mohou nastat případy:
\begin{itemize}
	\item Přihrádka je prázdná – hledaný prvek není v tabulce.
	\item V přihrádce je hledaný prvek x – vyhledávání tím úspěšně končí.
	\item V přihrádce je jiný prvek než x. Začneme postupně počítat další možné pozice a srovnávat prvky na nich s hledaným prvkem x, dokud buďto hledaný prvek nenalezneme anebo se nedostaneme na prázdnou přihrádku anebo nevyčerpáme všechny možné pozice.
\end{itemize}
\subsubsection{Zřetězení}
Předchozí metoda otevřeného adresování má dvě nevýhody:
\begin{itemize}
	\item Počet prvků, jež lze do tabulky uložit, je omezen její velikostí. Pokud dopředu neznáme, kolik prvků bude do tabulky ukládáno, může se stát, že ji stanovíme malou a dojde k jejímu přeplnění. Následné zvětšení velikosti tabulky je většinou časově náročně.
	\item Při vyhledávání, zejména v dost zaplněné tabulce, procházíme v důsledku otevřeného adresování i prvky, které mají jinou hodnotu hašovací funkce, čímž se doba vyhledávání zvětšuje.
\end{itemize}
Tyto nevýhody odstraňuje metoda zřetězení, která k ukládání dalších prvků se stejnou hodnotou hašovací funkce využívá seznamy. Hašovací tabulka v tomto případě obsahuje ukazatele na začátek (první uzel) jednotlivých seznamů. \\
Pokud potřebujeme do hašovací tabulky prvky nejen přidávat, ale i odebírat je, pak je nejvhodnější použít metodu zřetězení pro řešení kolicí. Odebrání se pak realizuje vyhledáním prvku v příslušném seznamu a zrušením uzlu, který odebíraný prvek obsahuje.\\
V případě, že odebírání bude v hašovací tabulce s otevřeným adresováním, je realizace odebírání o něco komplikovanější. Budeme rozeznávat tři různé stavy přihrádky tabulky:
\begin{itemize}
	\item Přihrádka je prázdná – v této přihrádce nikdy nebyl uložen žádný prvek.
	\item Přihrádka je volná – v této přihrádce byl uložen prvek, ale ten byl pak z tabulky odebrán.
	\item Přihrádka je obsazena – v této přihrádce je uložen prvek.
\end{itemize}
Při vyhledávání budeme volné přihrádky přeskakovat. Vyhledávání skončí, až když hledaný prvek najdeme nebo se dostaneme na prázdnou přihrádku (nebo jsme prošli celou tabulku, či její podstatnou část). Při přidávání budeme hledat první prázdnou nebo volnou přihrádku.
\paragraph{Časová složitost} vyhledávání je dána složitostí hašovací funkce (můžeme považovat za konstantní - řetězce mají omezenou délku). Při vkládání bez kolizí $\theta (1)$. Složitost roste s počtem kolizí v tabulce. Volba hašovací tabulky je zejména podstatná u metody otevřeného adresování. Volíme ji aspoň o 10\% větší, než je očekávaný počet prvků.
\paragraph{Perfektní hašování} Je hašování bez kolizí. Používá se v případech, kdy jsou známy prvky, které budou uloženy do hašovací tabulky. Pro tyto prvky se navrhne samostatná hašovací funkce, při jejímž použití nenastanou žádné kolize.
\paragraph{Minimální perfektní hašování} Je perfektní hašování, kdy navíc po uložení prvků nezůstanou v tabulce žádné volné přihrádky. Počet přihrádek v tabulce je tedy roven počtu uložených prvků. Nalezení takové hašovací funkce je ale obtížné.
\subsubsection{Extendible hashing}
Metoda hašování nazývaná extendible hashing nevyžaduje počáteční stanovení velikosti hašovací tabulky a navíc poskytuje konstantní časovou složitost vyhledání prvku bez ohledu na to, kolik prvků je do tabulky vloženo. Hašovací datová struktura se skládá ze dvou částí - adresáře a přihrádky. Adresář je pole odkazů na přihrádky. Velikost pole adresáře je $2^d$ odkazů. Hodnota d se dynamicky mění v závislosti na počtu prvků uložených v hašovací struktuře. Na začátku je zpravidla d malé. Při postupném zvyšování počtu ukládaných prvků do hašovací struktury se v určitých okamžicích hodnota d zvyšuje. Přihrádka je místo pro uložení pevně stanoveného počtu datových prvků. Velikost všech přihrádek je stejná. Základem metody je opět hašovací funkce, která datový prvek zobrazí na celé číslo. Posledních d bitů tohoto čísla je indexem v poli adresáře, kde najdeme odkaz na přihrádku, ve které je uložen daný prvek.
\paragraph{Vyhledání prvku v hašovací struktuře}
Jednotlivé bity hodnoty hašovací funkce si označíme: \\
$\cdots b_{d+1} b_d b_{d-1} \cdots b_3 b_2 b_1$ ($b_1$ je nejméně významný bit)
\begin{itemize}
	\item Vypočítáme hodnotu hašovací funkce hledaného prvku.
	\item Vezmeme posledních d bitů $b_d\cdots b_1$ vypočtené hodnoty hašovací funkce. Ty jsou indexem v poli adresáře. V něm v prvku, který odpovídá tomuto indexu, zjistíme odkaz na příslušnou přihrádku.
	\item V přihrádce procházíme v ní uložené prvky a srovnáváme je s hledaným prvkem, dokud nenalezneme prvek shodný s hledaným prvkem nebo je všechny neprojdeme (pak hledaný prvek není nalezen).
\end{itemize}
\paragraph{Přidání prvku do hašovací struktury}
\begin{itemize}
	\item Vypočítáme hodnotu hašovací funkce přidávaného prvku.
	\item Vezmeme posledních d bitů $b_d \cdots b_1$ vypočtené hodnoty hašovací funkce. Ty jsou indexem v poli adresáře. V něm v prvku pole, který odpovídá tomuto indexu, zjistíme odkaz na příslušnou přihrádku.
	\item Je-li v přihrádce místo pro uložení přidávaného prvku, prvek do přihrádky vložíme. Jinak je nutné přihrádku rozdělit.
\end{itemize}
\paragraph{Rozdělení přihrádky}
\begin{itemize}
	\item Pokud mají všechny prvky uložené v přihrádce stejnou hodnotu posledních d bitů $b_d \cdots b_1$ hodnot svých hašovacích funkcí, přihrádku rozdělíme na dvě a do první dáme prvky, jejichž hašovací funkce má hodnotu dalšího bitu $b_{d+1}$ rovnu 0. Do druhé dáme prvky, jejichž hodnota bitu $b_{d+1}$ je 1. Po rozdělení přihrádek následně i zdvojnásobíme velikost adresář (hodnotu d zvýšíme o 1). Při zdvojnásobení velikosti adresáře zachováme odkazy na přihrádky, které se nerozdělily. Pokud by bit $b_{d+1}$ byl u všech prvků stejný, vzali bychom další bit $b_{d+2}$ a adresář bychom zvětšili čtyřikrát (hodnotu d bychom zvýšili celkově o 2). Atd.
	\item Jestliže prvky uložené v přihrádce nemají shodnou hodnotu posledních d bitů hodnot svých hašovacích funkcí, rozdělíme je do dvou přihrádek podle prvního (bráno zleva) z d bitů, který není u všech prvků identický. Nechť je to bit b i, kde $i \leq d$ a i je největší index takový, že hodnota tohoto bitu hašovacích funkcí všech prvků není stejná. Následně v adresáři příslušně upravíme odkazy na tyto přihrádky.
\end{itemize}
\paragraph{Odebrání prvku z hašovací struktury}
\begin{itemize}
	\item Vyhledáme odebíraný prvek.
	\item Pokud byl nalezen, odstraníme ho z dané přihrádky.
\end{itemize}
Při větším odebírání, kdy vznikne více prázdných přihrádek, lze některé přihrádky sloučit. Případně po větším sloučení je někdy možné zmenšit velikost adresáře na polovinu. Jednoduchým způsobem lze sloučit prázdnou přihrádku, na kterou je jen jeden odkaz z adresáře, s přihrádkou, na kterou je opět jen jeden odkaz z adresáře a zároveň hodnoty indexů těchto odkazů v adresáři se liší jen v jednom bitu. Bylo by možné sloučit i v případě, že na obě slučované přihrádky je stejný počet $2^m$ odkazů a přitom hodnoty indexů jednotlivých odkazů v adresáři se liší právě v m bitech. Běžně se ale slučování přihrádek při odebírání nedělá.
\paragraph{Uložení na vnější paměti}
Použití této metody je vhodné, pokud by standardní hašovací tabulka byla tak rozsáhlá, že by se nevešla do paměti. U rozšiřitelného hašování stačí, aby v paměti byl uložen jen adresář. Přihrádky mohou být uloženy v souboru na vnější paměti.


\end{document}
